import{j as t,c as a,b as o,ag as d}from"./chunks/framework.BlzMDYBM.js";const m=JSON.parse('{"title":"模版方法模式","description":"","frontmatter":{},"headers":[],"relativePath":"code/golang/designer/14_template_method/README.md","filePath":"code/golang/designer/14_template_method/README.md","lastUpdated":1744879674000}'),c={name:"code/golang/designer/14_template_method/README.md"};function r(n,e,_,p,s,l){return o(),a("div",null,e[0]||(e[0]=[d('<h1 id="模版方法模式" tabindex="-1">模版方法模式 <a class="header-anchor" href="#模版方法模式" aria-label="Permalink to &quot;模版方法模式&quot;">​</a></h1><p>模版方法模式使用继承机制，把通用步骤和通用方法放到父类中，把具体实现延迟到子类中实现。使得实现符合开闭原则。</p><p>如实例代码中通用步骤在父类中实现（<code>准备</code>、<code>下载</code>、<code>保存</code>、<code>收尾</code>）下载和保存的具体实现留到子类中，并且提供 <code>保存</code>方法的默认实现。</p><p>因为Golang不提供继承机制，需要使用匿名组合模拟实现继承。</p><p>此处需要注意：因为父类需要调用子类方法，所以子类需要匿名组合父类的同时，父类需要持有子类的引用。</p>',5)]))}const g=t(c,[["render",r]]);export{m as __pageData,g as default};
