import{j as r,c as o,b as n,q as e,f as a}from"./chunks/framework.BlzMDYBM.js";const g=JSON.parse('{"title":"抽象工厂模式","description":"","frontmatter":{},"headers":[],"relativePath":"code/golang/designer/05_abstract_factory/README.md","filePath":"code/golang/designer/05_abstract_factory/README.md","lastUpdated":1744879674000}'),s={name:"code/golang/designer/05_abstract_factory/README.md"};function l(c,t,d,i,p,_){return n(),o("div",null,t[0]||(t[0]=[e("h1",{id:"抽象工厂模式",tabindex:"-1"},[a("抽象工厂模式 "),e("a",{class:"header-anchor",href:"#抽象工厂模式","aria-label":'Permalink to "抽象工厂模式"'},"​")],-1),e("p",null,"抽象工厂模式用于生成产品族的工厂，所生成的对象是有关联的。",-1),e("p",null,"如果抽象工厂退化成生成的对象无关联则成为工厂函数模式。",-1),e("p",null,[a("比如本例子中使用 "),e("code",null,"RDB"),a(" 和 "),e("code",null,"XML"),a(" 存储订单信息，抽象工厂分别能生成相关的主订单信息和订单详情信息。 如果业务逻辑中需要替换使用的时候只需要改动工厂函数相关的类就能替换使用不同的存储方式了。")],-1)]))}const m=r(s,[["render",l]]);export{g as __pageData,m as default};
